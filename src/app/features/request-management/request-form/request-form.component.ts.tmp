import { Component, OnDestroy, OnInit, ViewChild, ElementRef, ChangeDetectorRef, inject } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ActivatedRoute, Router } from '@angular/router';
import { MatSnackBar } from '@angular/material/snack-bar';
import { HttpEventType } from '@angular/common/http';
import { MatDialog } from '@angular/material/dialog';
import { Subscription } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { FormControl } from '@angular/forms';

// Models
import { Solicitacao } from '../../../shared/models/solicitacao.model';
import { Processo } from '../../../shared/models/processo.model';
import { User } from '../../../shared/models/user.model';
import { TipoSolicitacao } from '../../../shared/models/tiposolicitacao.model';
import { SolicitacaoStatus } from '../../../shared/models/solicitacao.model';
import { SolicitacaoAnexo } from '../../../shared/models/solicitacao-anexo.model';
import { Correspondente } from '../../../shared/models/correspondente.model';

// Components
import { ConfirmationDialogComponent } from '../../../shared/components/confirmation-dialog/confirmation-dialog.component';

// Services
import { SolicitacaoService } from '../../../core/services/solicitacao.service';
import { SolicitacaoStatusService } from '../../../core/services/solicitacao-status.service';
import { ProcessoService } from '../../../core/services/processo.service';
import { CorrespondenteService } from '../../../core/services/correspondente.service';
import { UserService } from '../../../core/services/user.service';
import { TipoSolicitacaoService } from '../../../core/services/tiposolicitacao.service';
import { SolicitacaoAnexoService } from '../../../core/services/solicitacao-anexo.service';
import { AuthService } from '../../../core/services/auth.service';
import { ExternalStorageAuthGuardService } from '../../../core/services/external-storage-auth-guard.service';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormsModule } from '@angular/forms';
import { MatInputModule } from '@angular/material/input';
import { MatSelectModule } from '@angular/material/select';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatRadioModule } from '@angular/material/radio';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatIconModule } from '@angular/material/icon';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatTooltipModule } from '@angular/material/tooltip';

interface ProgressInfo {
  value: number;
  fileName: string;
}

@Component({
  selector: 'app-request-form',
  templateUrl: './request-form.component.html',
  styleUrls: ['./request-form.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    FormsModule,
    MatInputModule,
    MatSelectModule,
    MatButtonModule,
    MatCardModule,
    MatRadioModule,
    MatProgressSpinnerModule,
    MatIconModule,
    MatAutocompleteModule,
    MatDatepickerModule,
    MatProgressBarModule,
    MatTooltipModule
  ]
})
export class RequestFormComponent implements OnInit, OnDestroy {
  @ViewChild('fileInput') fileInput!: ElementRef;
  
  requestForm: FormGroup;
  requestId: number | null = null;
  isEditMode = false;
  loading = false;
  message = '';
  
  // Dropdown data
  processos: Processo[] = [];
  filteredProcessos: Processo[] = [];
  correspondentes: Correspondente[] = [];
  filteredCorrespondentes: Correspondente[] = [];
  usuarios: User[] = [];
  tiposSolicitacao: TipoSolicitacao[] = [];
  statuses: SolicitacaoStatus[] = [];
  
  // File upload related
  selectedFiles: File[] = [];
  progressInfos: ProgressInfo[] = [];
  currentFiles: SolicitacaoAnexo[] = [];
  
  // Conditional field visibility
  showAudienciaFields = false;
  showValorField = false;
  
  // Theme subscription
  themeSubscription: Subscription | null = null;
  
  // Loaded solicitacao for edit mode
  loadedSolicitacao: Solicitacao | null = null;
  
  // Storage location selection
  storageLocation: 'local' | 'google_drive' = 'google_drive';
  
  // Search controls for dropdowns
  processoSearchControl = new FormControl('');
  correspondenteSearchControl = new FormControl('');

  // Using inject() function instead of constructor injection
  private formBuilder = inject(FormBuilder);
  private router = inject(Router);
  private route = inject(ActivatedRoute);
  private snackBar = inject(MatSnackBar);
  private dialog = inject(MatDialog);
  private solicitacaoService = inject(SolicitacaoService);
  private solicitacaoStatusService = inject(SolicitacaoStatusService);
  private processoService = inject(ProcessoService);
  private correspondenteService = inject(CorrespondenteService);
  private userService = inject(UserService);
  private tipoSolicitacaoService = inject(TipoSolicitacaoService);
  // Add the new attachment service
  private solicitacaoAnexoService = inject(SolicitacaoAnexoService);
  // Inject AuthService to determine user role
  private authService = inject(AuthService);
  // Add external storage auth guard service
  private externalStorageAuthGuard = inject(ExternalStorageAuthGuardService);
  // Inject ChangeDetectorRef
  private changeDetectorRef = inject(ChangeDetectorRef);

  constructor() {
    this.requestForm = this.createForm();
  }

  ngOnInit(): void {
    this.loadDropdownData();
    
    // Set up processo search
    this.processoSearchControl.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged()
    ).subscribe(searchTerm => {
      if (typeof searchTerm === 'string') {
        this.filterProcessos(searchTerm || '');
      } else if (searchTerm && typeof searchTerm === 'object') {
        // If it's a Processo object, set the form control to the ID
        this.requestForm.get('processo')?.setValue((searchTerm as Processo).id);
      }
    });
    
    // Set up correspondente search
    this.correspondenteSearchControl.valueChanges.pipe(
      debounceTime(300),
      distinctUntilChanged()
    ).subscribe(searchTerm => {
      if (typeof searchTerm === 'string' && searchTerm.length > 2) {
        this.searchCorrespondentes(searchTerm);
      } else if (!searchTerm) {
        // If no search term, show filtered correspondentes (active only)
        this.filteredCorrespondentes = this.correspondentes.filter(c => c.ativo === true);
      }
    });
    
    // Check if we're in edit mode
    this.route.params.subscribe(params => {
      if (params['id']) {
        this.isEditMode = true;
        this.requestId = +params['id'];
        this.loadRequest();
        // Load existing attachments for this request
        this.loadAnexos();
      }
    });
    
    this.setupThemeListener();
  }

  ngOnDestroy(): void {
    if (this.themeSubscription) {
      this.themeSubscription.unsubscribe();
    }
  }

  setupThemeListener(): void {
    // Listen for theme changes to trigger change detection
    this.themeSubscription = new Subscription();
    const themeHandler = () => {
      // Force change detection when theme changes
      // This will cause the component to re-render with the new theme styles
    };
    
    window.addEventListener('themeChanged', themeHandler);
    // Clean up the event listener when component is destroyed
    this.themeSubscription.add(() => {
      window.removeEventListener('themeChanged', themeHandler);
    });
  }

  private createForm(): FormGroup {
    const form = this.formBuilder.group({
      tipoSolicitacao: [null, Validators.required],
      status: [''], // Will be set to "Aguardando Confirmação" in onSubmit for new solicitations
      processo: [null, Validators.required], // This will be set by the autocomplete selection
      correspondente: [null, Validators.required],
      usuario: [null, Validators.required],
      dataSolicitacao: [this.getCurrentDate()], // Pre-filled with current date but editable by user
      dataPrazo: [''],
      instrucoes: [''],
      // Conditional fields
      dataAgendamento: [''],
      horaAudiencia: [''], // Changed from horaAudiencia to match model property
      valor: [''], // Remove initial validator, let onTipoSolicitacaoChange handle it
      storageLocation: ['google_drive'] // Add storage location control
    });
    
    // Debug log removed
    return form;
  }

  // Helper method to get current date in YYYY-MM-DD format
  private getCurrentDate(): string {
    const today = new Date();
    const year = today.getFullYear();
    const month = (today.getMonth() + 1).toString().padStart(2, '0');
    const day = today.getDate().toString().padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Helper method to format date for display
  private formatDateForDisplay(dateString: string): string {
    if (!dateString) return '';
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    return `${day}/${month}/${year}`;
  }

  private loadDropdownData(): void {
    // Load all processos initially (for search functionality)
    this.processoService.getProcessosPaginated(0, 10000, 'numeroprocesso', 'ASC').subscribe({
      next: (response) => {
        const processos = response.content || [];
        this.processos = processos;
        
        // Filter to only show processes with status "EM_ANDAMENTO"
        this.filteredProcessos = this.processos.filter(p => p.status === 'EM_ANDAMENTO');
        
        // If no processes with "EM_ANDAMENTO" status, show all processes
        if (this.filteredProcessos.length === 0) {
          this.filteredProcessos = this.processos;
        }
        
        // Force change detection to ensure the template updates
        this.changeDetectorRef.detectChanges();
      },
      error: (error) => {
        console.error('Error loading processos:', error);
        this.snackBar.open('Erro ao carregar processos', 'Fechar', { duration: 5000 });
      }
    });

    // Load correspondentes
    this.correspondenteService.getCorrespondentes().subscribe({
      next: (correspondentes) => {
        this.correspondentes = correspondentes;
        // Filter to only show active correspondentes
        this.filteredCorrespondentes = correspondentes.filter(c => c.ativo === true);
      },
      error: (error) => {
        console.error('Error loading correspondentes:', error);
        this.snackBar.open('Erro ao carregar correspondentes', 'Fechar', { duration: 5000 });
      }
    });

    // Load usuarios
    this.userService.getUsers().subscribe({
      next: (usuarios) => {
        this.usuarios = usuarios;
      },
      error: (error) => {
        console.error('Error loading usuarios:', error);
        this.snackBar.open('Erro ao carregar usuários', 'Fechar', { duration: 5000 });
      }
    });

    // Load tipos de solicitacao
    this.tipoSolicitacaoService.getTiposSolicitacao().subscribe({
      next: (tipos) => {
        this.tiposSolicitacao = tipos;
      },
      error: (error) => {
        console.error('Error loading tipos de solicitacao:', error);
        this.snackBar.open('Erro ao carregar tipos de solicitação', 'Fechar', { duration: 5000 });
      }
    });

    // Load statuses
    this.solicitacaoStatusService.getSolicitacaoStatuses().subscribe({
      next: (statuses) => {
        this.statuses = statuses;
      },
      error: (error) => {
        console.error('Error loading statuses:', error);
        this.snackBar.open('Erro ao carregar status', 'Fechar', { duration: 5000 });
      }
    });
  }

  // Method to filter processos based on search term
  private filterProcessos(searchTerm: string): void {
    if (!searchTerm) {
      // If no search term, show filtered processos (EM_ANDAMENTO or all)
      this.filteredProcessos = this.processos.filter(p => p.status === 'EM_ANDAMENTO');
      if (this.filteredProcessos.length === 0) {
        this.filteredProcessos = this.processos;
      }
      return;
    }
    
    // Filter processos based on search term (number or part name)
    this.filteredProcessos = this.processos.filter(p => 
      p.numeroprocesso.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (p.parte && p.parte.toLowerCase().includes(searchTerm.toLowerCase()))
    );
  }

  // Method to handle processo selection from autocomplete
  onProcessoSelected(event: { option: { value: Processo } }): void {
    const selectedProcesso = event.option.value;
    this.requestForm.get('processo')?.setValue(selectedProcesso.id);
    
    // Update the form control with the selected processo ID
    this.requestForm.patchValue({
      processo: selectedProcesso.id
    });
  }

  // Method to display processo in autocomplete
  displayProcesso(processo: Processo): string {
    return processo && processo.numeroprocesso ? `${processo.numeroprocesso} - ${processo.parte || ''}` : '';
  }

  private loadRequest(): void {
    if (!this.requestId) return;
    
    this.loading = true;
    this.solicitacaoService.getSolicitacaoById(this.requestId).subscribe({
      next: (solicitacao) => {
        // Store the complete solicitacao object to preserve fields not in the form
        this.loadedSolicitacao = solicitacao;
        
        // Ensure dataSolicitacao is populated with current date if empty
        const dataSolicitacaoValue = solicitacao.datasolicitacao || this.getCurrentDate();
        
        // Format the valor for display if it exists
        let formattedValor = null;
        if (solicitacao.valor !== null && solicitacao.valor !== undefined) {
          formattedValor = solicitacao.valor;
        }
        
        // Set form values
        this.requestForm.patchValue({
          tipoSolicitacao: solicitacao.tipoSolicitacao?.idtiposolicitacao || null,
          status: solicitacao.statusSolicitacao?.idstatus || (this.statuses && this.statuses.length > 0 ? this.statuses[0].idstatus : 1),
          processo: solicitacao.processo?.id || null,
          correspondente: solicitacao.correspondente?.id || null,
          usuario: solicitacao.usuario?.id || null,
          dataSolicitacao: dataSolicitacaoValue,
          dataPrazo: solicitacao.dataprazo || '',
          instrucoes: solicitacao.instrucoes || '',
          observacao: solicitacao.observacao || '',
          // Conditional fields
          dataAgendamento: solicitacao.dataagendamento || '',
          horaAudiencia: solicitacao.horaudiencia || '',
          valor: formattedValor
        });
        
        // Set the processo search control to the selected processo for display
        if (solicitacao.processo) {
          this.processoSearchControl.setValue(this.displayProcesso(solicitacao.processo));
        }
        
        // Set the correspondente search control to the selected correspondente for display
        if (solicitacao.correspondente) {
          this.correspondenteSearchControl.setValue(this.displayCorrespondente(solicitacao.correspondente));
        }
        
        // Check if we need to show conditional fields based on the loaded tipoSolicitacao
        if (solicitacao.tipoSolicitacao?.idtiposolicitacao) {
          this.updateConditionalFields(solicitacao.tipoSolicitacao.idtiposolicitacao);
        }
        
        // Ensure conditional fields are shown if they have values (for edit mode)
        if (solicitacao.dataagendamento || solicitacao.horaudiencia) {
          this.showAudienciaFields = true;
        }
        
        this.loading = false;
      },
      error: (error) => {
        console.error('Error loading solicitacao:', error);
        this.snackBar.open('Erro ao carregar solicitação', 'Fechar', { duration: 5000 });
        this.loading = false;
        this.router.navigate(['/solicitacoes']);
      }
    });
  }

  // Load existing attachments for the current request
  private loadAnexos(): void {
    if (!this.requestId) return;
    
    this.solicitacaoAnexoService.getAnexosBySolicitacaoId(this.requestId).subscribe({
      next: (anexos) => {
        this.currentFiles = anexos;
      },
      error: (error) => {
        console.error('Error loading attachments:', error);
        this.snackBar.open('Erro ao carregar anexos', 'Fechar', { duration: 5000 });
      }
    });
  }

  // Method to handle file selection
  selectFiles(event: Event): void {
    const target = event.target as HTMLInputElement;
    this.selectedFiles = Array.from(target.files || []);
    this.progressInfos = [];
    this.message = '';
  }

  // Method to format currency input for Brazilian format
  formatCurrency(event: Event): void {
    const input = event.target as HTMLInputElement;
    let value = input.value.replace(/\D/g, ''); // Remove all non-digit characters
    value = (Number(value) / 100).toFixed(2); // Convert to decimal format
    
    // Format with Brazilian currency format
    const formattedValue = new Intl.NumberFormat('pt-BR', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Number(value));
    
    input.value = formattedValue;
    
    // Update the form control value
    const numericValue = Number(value);
    this.requestForm.get('valor')?.setValue(numericValue);
  }

  // Method to format a number as Brazilian currency for display
  formatCurrencyDisplay(value: number | string | null): string {
    if (value === null || value === undefined || value === '') {
      return '';
    }
    
    // Convert string to number if needed
    let numericValue: number;
    if (typeof value === 'string') {
      // Remove any existing formatting
      const cleanValue = value.replace(/[^0-9,]/g, '').replace(',', '.');
      numericValue = parseFloat(cleanValue);
      if (isNaN(numericValue)) {
        return '';
      }
    } else {
      numericValue = value;
    }
    
    // Format as Brazilian currency without the R$ symbol
    return numericValue.toLocaleString('pt-BR', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    });
  }

  // Helper method to check if a tipoSolicitacao is Audiência
  private isTipoAudiencia(tipoSolicitacao: TipoSolicitacao): boolean {
    if (!tipoSolicitacao) return false;
    
    const especie = tipoSolicitacao.especie?.toLowerCase() || '';
    const tipo = tipoSolicitacao.tipo?.toLowerCase() || '';
    
    return especie.includes('audiencia') || especie.includes('audiência') || 
           tipo.includes('audiencia') || tipo.includes('audiência');
  }
  
  // Helper method to check if a tipoSolicitacao is Diligência
  private isTipoDiligencia(tipoSolicitacao: TipoSolicitacao): boolean {
    if (!tipoSolicitacao) return false;
    
    const especie = tipoSolicitacao.especie?.toLowerCase() || '';
    const tipo = tipoSolicitacao.tipo?.toLowerCase() || '';
    
    // Debug log removed
    
    // Match the diligência detection logic used in the dashboard
    const isDiligencia = especie.includes('diligencia') || especie.includes('diligência') || 
           tipo.includes('diligencia') || tipo.includes('diligência') ||
           especie.includes('dilig') || tipo.includes('dilig') ||
           especie.includes('cumprimento') || tipo.includes('cumprimento');
           
    // Debug log removed
    return isDiligencia;
  }
  
  // Method to handle tipoSolicitacao selection change
  onTipoSolicitacaoChange(tipoSolicitacaoId: number): void {
    // Debug log removed
    this.updateConditionalFields(tipoSolicitacaoId);
    
    // Update validator for valor field based on showValorField
    const valorControl = this.requestForm.get('valor');
    if (this.showValorField) {
      valorControl?.setValidators(Validators.required);
    } else {
      valorControl?.clearValidators();
    }
    valorControl?.updateValueAndValidity();
    
    // Force change detection to ensure the template updates
    this.changeDetectorRef.detectChanges();
  }

  // Method to update visibility of conditional fields based on tipoSolicitacao
  private updateConditionalFields(tipoSolicitacaoId: number): void {
    // Debug log removed
    // Find the selected tipoSolicitacao
    const selectedTipo = this.tiposSolicitacao.find(tipo => tipo.idtiposolicitacao === tipoSolicitacaoId);
    
    // Debug log removed
    
    if (selectedTipo) {
      // Check if it's "Audiência" (case insensitive, with or without accents)
      const isAudiencia = this.isTipoAudiencia(selectedTipo);
      // For diligência, we hide the audiência fields
      const isDiligencia = this.isTipoDiligencia(selectedTipo);
      
      // Debug log removed
      
      // Show/hide fields based on tipo - only show for audiencia, hide for diligencia
      this.showAudienciaFields = isAudiencia;
      this.showValorField = isAudiencia || isDiligencia;
      
      // Debug log removed
      // Debug log removed
      
      // Additional logging for debugging
      // Debug log removed
    } else {
      // Default to hiding conditional fields
      this.showAudienciaFields = false;
      this.showValorField = false;
      // Debug log removed
      // Debug log removed
    }
    
    // Special case: If we're in edit mode and already have audiencia data, ensure fields are visible
    if (this.isEditMode) {
      const formValue = this.requestForm.getRawValue();
      // Debug log removed
      
      if (formValue.dataAgendamento || formValue.horaAudiencia) {
        // Only show for audiencia types in edit mode
        if (selectedTipo && this.isTipoAudiencia(selectedTipo)) {
          this.showAudienciaFields = true;
          // Debug log removed
        }
      }
      
      // Also check if the current tipoSolicitacao is Audiência
      if (selectedTipo && this.isTipoAudiencia(selectedTipo)) {
        this.showAudienciaFields = true;
        // Debug log removed
      }
      
      // Ensure valor field is visible if there's a value (for both audiencia and diligencia)
      if (formValue.valor) {
        this.showValorField = true;
        // Debug log removed
      }
    }
    
    // Debug log removed
    // Debug log removed
    
    // Force change detection to ensure the template updates
    this.changeDetectorRef.detectChanges();
  }

  private uploadAnexos(solicitacaoId: number): void {
    this.message = '';
    this.progressInfos = [];

    if (this.selectedFiles.length === 0) {
      return;
    }

    for (const file of this.selectedFiles) {
      this.progressInfos.push({ value: 0, fileName: file.name });
    }

    for (const [index, file] of this.selectedFiles.entries()) {
      this.uploadAnexo(solicitacaoId, file, index);
    }
  }

  // Method to perform the actual upload
  private performUpload(solicitacaoId: number): void {
    this.message = '';
    this.progressInfos = [];

    if (this.selectedFiles.length === 0) {
      return;
    }

    for (const file of this.selectedFiles) {
      this.progressInfos.push({ value: 0, fileName: file.name });
    }

    for (const [index, file] of this.selectedFiles.entries()) {
      this.uploadAnexo(solicitacaoId, file, index);
    }
  }

  // Method to upload a single file
  private uploadAnexo(solicitacaoId: number, file: File, index: number): void {
    this.solicitacaoAnexoService.uploadAnexo(file, solicitacaoId, this.storageLocation).subscribe({
      next: (event) => {
        if (event.type === HttpEventType.UploadProgress) {
          // Upload progress
          if (event.total) {
            const progress = Math.round(100 * event.loaded / event.total);
            this.progressInfos[index].value = progress;
          }
        } else if (event.type === HttpEventType.Response) {
          // Upload complete
          this.message = 'Arquivo(s) carregado(s) com sucesso!';
          // Reload the current attachments
          this.loadAnexos();
          // Clear selected files
          this.selectedFiles = [];
          this.progressInfos = [];
        }
      },
      error: (err) => {
        this.progressInfos[index].value = 0;
        this.message = 'Erro ao carregar arquivo: ' + file.name;
        console.error('Error uploading file:', err);
        this.snackBar.open('Erro ao carregar arquivo: ' + file.name, 'Fechar', { duration: 5000 });
      }
    });
  }

  // Method to remove a file from the selected files list
  removeSelectedFile(index: number): void {
    this.selectedFiles.splice(index, 1);
    if (this.progressInfos[index]) {
      this.progressInfos.splice(index, 1);
    }
  }

  onSubmit(): void {
    if (this.requestForm.invalid) {
      this.markFormGroupTouched();
      return;
    }

    this.loading = true;
    
    // Prepare solicitacao data
    const solicitacao = this.prepareSolicitacaoData();
    
    // Show confirmation dialog
    const dialogRef = this.dialog.open(ConfirmationDialogComponent, {
      width: '400px',
      data: {
        title: 'Confirmar operação',
        message: `Tem certeza que deseja ${this.isEditMode ? 'atualizar' : 'criar'} esta solicitação?`,
        confirmText: 'SIM',
        cancelText: 'NÃO'
      }
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) {
        if (this.isEditMode && this.requestId) {
          this.solicitacaoService.updateSolicitacao(this.requestId, solicitacao).subscribe({
            next: (updated) => {
              this.loading = false;
              this.snackBar.open('Solicitação atualizada com sucesso!', 'Fechar', {
                duration: 3000,
                panelClass: ['success-snackbar']
              });
              this.router.navigate(['/solicitacoes', updated.id]);
            },
            error: (error) => {
              this.loading = false;
              console.error('Error updating solicitacao:', error);
              this.snackBar.open('Erro ao atualizar solicitação', 'Fechar', {
                duration: 5000,
                panelClass: ['error-snackbar']
              });
            }
          });
        } else {
          this.solicitacaoService.createSolicitacao(solicitacao).subscribe({
            next: (created) => {
              this.loading = false;
              this.snackBar.open('Solicitação criada com sucesso!', 'Fechar', {
                duration: 3000,
                panelClass: ['success-snackbar']
              });
              this.router.navigate(['/solicitacoes', created.id]);
            },
            error: (error) => {
              this.loading = false;
              console.error('Error creating solicitacao:', error);
              this.snackBar.open('Erro ao criar solicitação', 'Fechar', {
                duration: 5000,
                panelClass: ['error-snackbar']
              });
            }
          });
        }
      } else {
        this.loading = false;
      }
    });
  }

  private prepareSolicitacaoData(): Solicitacao {
    const formValue = this.requestForm.value;
    const solicitacao: Partial<Solicitacao> = this.loadedSolicitacao ? { ...this.loadedSolicitacao } : {};
    
    // Map form values to solicitacao object
    solicitacao.tipoSolicitacao = { idtiposolicitacao: formValue.tipoSolicitacao };
    solicitacao.processo = { id: formValue.processo } as Processo;
    
    // Set status based on edit mode
    if (this.isEditMode && formValue.status) {
      solicitacao.statusSolicitacao = this.statuses.find(s => s.idstatus === formValue.status) || 
        { idstatus: formValue.status, status: 'Aguardando Confirmação' };
    } else if (!this.isEditMode) {
      // For new solicitations, set default status
      solicitacao.statusSolicitacao = { idstatus: 1, status: 'Aguardando Confirmação' };
    }
    
    // Handle conditional fields
    if (this.showAudienciaFields) {
      solicitacao.dataagendamento = formValue.dataAgendamento;
      solicitacao.horaudiencia = formValue.horaAudiencia;
    }
    
    if (this.showValorField) {
      solicitacao.valor = formValue.valor;
    }
    
    solicitacao.dataprazo = formValue.dataPrazo;
    solicitacao.complemento = formValue.complemento;
    solicitacao.instrucoes = formValue.instrucoes;
    
    // Set correspondent if available
    if (this.authService.currentUserValue?.correspondente?.id) {
      solicitacao.correspondente = { id: this.authService.currentUserValue.correspondente.id } as Correspondente;
    }
    
    return solicitacao as Solicitacao;
  }

  onCancel(): void {
    if (this.isEditMode && this.requestId) {
      // When editing, go back to the detail page
      this.router.navigate(['/solicitacoes', this.requestId]);
    } else {
      // When creating new, go back to the list
      this.router.navigate(['/solicitacoes']);
    }
  }

  private markFormGroupTouched(): void {
    Object.keys(this.requestForm.controls).forEach(key => {
      const control = this.requestForm.get(key);
      control?.markAsTouched();
    });
  }
  
  // Helper method to check if a field has an error and has been touched
  isFieldInvalid(fieldName: string): boolean {
    const field = this.requestForm.get(fieldName);
    return !!(field && field.invalid && field.touched);
  }
  
  // Helper method to get error message for a field
  getFieldErrorMessage(fieldName: string): string {
    const field = this.requestForm.get(fieldName);
    if (field && field.errors) {
      if (field.errors['required']) {
        const fieldLabels: Record<string, string> = {
          'processo': 'Processo',
          'correspondente': 'Correspondente',
          'tipoSolicitacao': 'Tipo de Solicitação',
          'usuario': 'Usuário',
          'valor': 'Valor'
        };
        return `${fieldLabels[fieldName] || fieldName} é obrigatório`;
      }
    }
    return '';
  }
  
  private getErrorMessage(fieldName: string): string {
    const field = this.requestForm.get(fieldName);
    if (!field || !field.errors) return '';
    
    const fieldLabels: Record<string, string> = {
      tipoSolicitacao: 'Tipo de Solicitação',
      processo: 'Processo',
      valor: 'Valor',
      dataPrazo: 'Data do Prazo',
      dataAgendamento: 'Data do Agendamento',
      horaAudiencia: 'Hora da Audiência',
      complemento: 'Complemento',
      instrucoes: 'Instruções'
    };
    
    const label = fieldLabels[fieldName] || fieldName;
    
    if (field.hasError('required')) {
      return `${label} é obrigatório`;
    }
    
    if (field.hasError('min')) {
      return `${label} deve ser maior que zero`;
    }
    
    return 'Campo inválido';
  }
  
  // Method to get the CSS class for an attachment based on its origin
  getAttachmentClass(anexo: SolicitacaoAnexo): string {
    if (anexo.origem === 'correspondente') {
      return 'attachment-correspondente';
    } else {
      return 'attachment-solicitante';
    }
  }
  
  // Method to format dates with time for display (specifically for file upload timestamps)
  formatDateTime(date: Date | string | undefined): string {
    if (!date) return '';
    
    // Handle different date formats
    let dateObj: Date;
    if (typeof date === 'string') {
      // Try to parse different date formats
      if (date.includes(',')) {
        // Handle comma-separated format like "2025,9,11,3,0"
        const parts = date.split(',').map(Number);
        dateObj = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4]);
      } else if (date.includes('/')) {
        // Handle Brazilian format like "11/09/2025"
        const parts = date.split('/');
        dateObj = new Date(parseInt(parts[2]), parseInt(parts[1]) - 1, parseInt(parts[0]));
      } else {
        // Handle ISO format or other standard formats
        dateObj = new Date(date);
      }
    } else {
      dateObj = date;
    }
    
    // Format as DD/MM/YYYY HH:mm
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const hours = dateObj.getHours().toString().padStart(2, '0');
    const minutes = dateObj.getMinutes().toString().padStart(2, '0');
    
    return `${day}/${month}/${year} ${hours}:${minutes}`;
  }
  
  // Method to download an attachment
  downloadAnexo(anexoId: number, nomeArquivo: string, storageLocation?: string): void {
    // Check storage location and proceed accordingly
    if (storageLocation === 'google_drive') {
      // For Google Drive, check external storage authentication before downloading
      this.externalStorageAuthGuard.checkAuthentication().subscribe({
        next: (isAuthenticated) => {
          if (isAuthenticated) {
            // Proceed with download if authenticated
            this.performDownload(anexoId, nomeArquivo);
          } else {
            // Show message if not authenticated
            this.snackBar.open('Download cancelado. Por favor, autentique-se com o armazenamento externo primeiro.', 'Fechar', { duration: 5000 });
          }
        },
